import { supabase } from './supabase'
import type { Tool } from '../types'

export interface AdminUser {
  id: string
  user_id: string
  role: 'super_admin' | 'admin' | 'moderator'
  permissions: Record<string, boolean>
  created_at: string
  updated_at: string
}

export interface AdminLog {
  id: string
  admin_id: string
  action: string
  target_type: string
  target_id?: string
  details: Record<string, unknown>
  ip_address?: string
  user_agent?: string
  created_at: string
}

export interface ToolSubmission {
  id: string
  submitter_email?: string
  tool_name: string
  tagline: string
  description?: string
  website_url: string
  logo_url?: string
  categories: string[]
  features: string[]
  pricing: 'Free' | 'Freemium' | 'Paid' | 'Trial'
  status: 'pending' | 'approved' | 'rejected'
  admin_notes?: string
  reviewed_by?: string
  reviewed_at?: string
  created_at: string
  updated_at: string
}

// é€šç”¨ï¼šå¸¦è¶…æ—¶çš„ JSON è¯·æ±‚
async function fetchJSONWithTimeout(
  url: string,
  options: RequestInit & { timeoutMs?: number } = {}
) {
  const { timeoutMs = 8000, ...rest } = options
  const controller = new AbortController()
  const id = setTimeout(() => controller.abort(), timeoutMs)
  try {
    const resp = await fetch(url, { ...rest, signal: controller.signal })
    if (!resp.ok) {
      // å°è¯•è§£æåç«¯è¿”å›çš„é”™è¯¯ä¿¡æ¯
      const text = await resp.text().catch(() => '')
      try {
        const json = text ? JSON.parse(text) : null
        const msg = json?.error || json?.message || resp.statusText || `HTTP ${resp.status}`
        throw new Error(msg)
      } catch {
        const msg = text || resp.statusText || `HTTP ${resp.status}`
        throw new Error(msg)
      }
    }
    return await resp.json()
  } finally {
    clearTimeout(id)
  }
}

async function postJSONWithTimeout(
  url: string,
  body: unknown,
  options: RequestInit & { timeoutMs?: number } = {}
) {
  const { timeoutMs = 12000, headers, ...rest } = options
  const controller = new AbortController()
  const id = setTimeout(() => controller.abort(), timeoutMs)
  try {
    let attempt = 0
    let lastErr: Error | null = null
    while (attempt < 3) {
      try {
        const resp = await fetch(url, {
          method: 'POST',
          headers: { 'content-type': 'application/json', ...(headers || {}) },
          body: JSON.stringify(body ?? {}),
          signal: controller.signal,
          cache: 'no-store',
          ...rest
        })
        if (!resp.ok) {
          const text = await resp.text().catch(() => '')
          try {
            const json = text ? JSON.parse(text) : null
            const msg = json?.error || json?.message || resp.statusText || `HTTP ${resp.status}`
            throw new Error(msg)
          } catch {
            const msg = text || resp.statusText || `HTTP ${resp.status}`
            throw new Error(msg)
          }
        }
        const text = await resp.text()
        try { return text ? JSON.parse(text) : null } catch { return null }
      } catch (e) {
        lastErr = e
        attempt += 1
        await new Promise(r => setTimeout(r, 300 * attempt))
      }
    }
    throw lastErr
  } finally {
    clearTimeout(id)
  }
}

// ç­‰å¾…è·å–å¯ç”¨çš„ Access Tokenï¼ˆè§£å†³é¡µé¢åˆå§‹æ—¶ä¼šè¯å°šæœªæ¢å¤å¯¼è‡´çš„ No session/ç©ºæ•°æ®ï¼‰
let accessTokenCache: string | null = null

function readTokenFromLocalStorage(): string | null {
  try {
    const key = Object.keys(localStorage).find(k => k.includes('sb-') && k.endsWith('-auth-token'))
    if (!key) return null
    const raw = localStorage.getItem(key)
    if (!raw) return null
    const parsed = JSON.parse(raw)
    return parsed?.currentSession?.access_token || parsed?.access_token || null
  } catch {
    return null
  }
}

async function ensureAccessToken(timeoutMs = 3000): Promise<string> {
  // 0) å…ˆçœ‹ç¼“å­˜ï¼Œé¿å…å¹¶å‘é‡å¤ç­‰å¾…
  if (accessTokenCache) return accessTokenCache

  // 1) LocalStorage å‘½ä¸­æœ€å¿«
  const lsFirst = readTokenFromLocalStorage()
  if (lsFirst) {
    accessTokenCache = lsFirst
    return lsFirst
  }

  const start = Date.now()
  while (Date.now() - start < timeoutMs) {
    // 2) è¯» supabase ä¼šè¯
    const { data: sessionRes } = await supabase.auth.getSession()
    const token = sessionRes?.session?.access_token
    if (token) {
      accessTokenCache = token
      return token
    }

    // 3) å†å°è¯• LocalStorageï¼ˆä¼šè¯å¯èƒ½åˆšåˆšå†™å…¥ï¼‰
    const lsToken = readTokenFromLocalStorage()
    if (lsToken) {
      accessTokenCache = lsToken
      return lsToken
    }

    await new Promise((r) => setTimeout(r, 150))
  }
  throw new Error('No session')
}

// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä¸ºç®¡ç†å‘˜
export async function checkAdminStatus(): Promise<AdminUser | null> {
  // å®¹å¿ä¼šè¯å°šæœªå®Œå…¨æ¢å¤ï¼Œä¼˜å…ˆæ‹¿ tokenï¼Œå†è·å–ç”¨æˆ·
  const token = await ensureAccessToken().catch(() => null)
  const { data: userRes } = await supabase.auth.getUser()
  const userId = userRes?.user?.id || null
  console.log('ğŸ” æ£€æŸ¥ç”¨æˆ·ç™»å½•çŠ¶æ€:', userRes?.user?.email)

  if (!token) {
    console.log('âŒ æœªè·å–åˆ° token')
    return null
  }

  try {
    // ç®€åŒ–ç®¡ç†å‘˜æƒé™æ£€æŸ¥ - ç›´æ¥ä½¿ç”¨Supabaseå®¢æˆ·ç«¯è€Œä¸ä¾èµ–Netlify Functions
    const adminEmails = ['admin@civilaihub.com', 'admin@tumuai.net', '307714007@qq.com']
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user || !adminEmails.includes(user.email || '')) {
      console.log('âŒ éç®¡ç†å‘˜ç”¨æˆ·:', user?.email)
      return null
    }
    
    console.log('âœ… ç®¡ç†å‘˜æƒé™éªŒè¯æˆåŠŸ:', user.email)
    return {
      user_id: user.id,
      email: user.email,
      role: 'admin',
      is_super_admin: user.email === '307714007@qq.com'
    } as AdminUser
  } catch (error) {
    console.error('âŒ ç®¡ç†å‘˜æƒé™æ£€æŸ¥å¼‚å¸¸:', error)
    return null
  }
}

// è®°å½•ç®¡ç†å‘˜æ“ä½œ
export async function logAdminAction(
  action: string,
  targetType: string,
  targetId?: string,
  details?: Record<string, unknown>
) {
  const admin = await checkAdminStatus()
  if (!admin) throw new Error('Unauthorized')

  const { error } = await supabase
    .from('admin_logs')
    .insert([{
      admin_id: admin.id,
      action,
      target_type: targetType,
      target_id: targetId,
      details: details || {}
    }])

  if (error) throw error
}

// è·å–ç³»ç»Ÿç»Ÿè®¡æ•°æ® - ç®€åŒ–ç‰ˆæœ¬
export async function getSystemStats() {
  try {
    // ç›´æ¥ä»SupabaseæŸ¥è¯¢ç»Ÿè®¡æ•°æ®
    const [toolsCount, publishedCount, pendingCount] = await Promise.all([
      supabase.from('tools').select('id', { count: 'exact', head: true }),
      supabase.from('tools').select('id', { count: 'exact', head: true }).eq('status', 'published'),
      supabase.from('tools').select('id', { count: 'exact', head: true }).eq('status', 'pending')
    ])
    
    return {
      totalTools: toolsCount.count || 0,
      publishedTools: publishedCount.count || 0, 
      pendingTools: pendingCount.count || 0,
      categories: 6 // å›ºå®šå€¼ï¼ŒåŸºäºç°æœ‰åˆ†ç±»
    }
  } catch (error) {
    console.error('âŒ è·å–ç»Ÿè®¡æ•°æ®å¼‚å¸¸:', error)
    // è¿”å›ç¤ºä¾‹æ•°æ®è€Œä¸æ˜¯å…¨0ï¼Œä»¥ä¾¿è°ƒè¯•
    return { 
      totalTools: 0, 
      publishedTools: 0, 
      pendingTools: 0, 
      categories: 6
    }
  }
}

// è·å–å·¥å…·æäº¤åˆ—è¡¨ - ç®€åŒ–ç‰ˆæœ¬
export async function getToolSubmissions(status?: string) {
  try {
    // ç›´æ¥ä»SupabaseæŸ¥è¯¢å·¥å…·æ•°æ®
    let query = supabase
      .from('tools')
      .select('*')
      .order('created_at', { ascending: false })
    
    if (status) {
      query = query.eq('status', status)
    }
    
    const { data, error } = await query
    if (error) throw error
    
    return data || []
  } catch (error) {
    console.error('âŒ è·å–å·¥å…·æäº¤å¼‚å¸¸:', error)
    return []
  }
}

// å®¡æ ¸å·¥å…·æäº¤ - ç®€åŒ–ç‰ˆæœ¬
export async function reviewToolSubmission(
  submissionId: string,
  status: 'approved' | 'rejected',
  adminNotes?: string
) {
  try {
    const newStatus = status === 'approved' ? 'published' : 'rejected'
    const { error } = await supabase
      .from('tools')
      .update({ 
        status: newStatus,
        updated_at: new Date().toISOString()
      })
      .eq('id', submissionId)
    
    if (error) throw error
  } catch (error) {
    console.error('âŒ å®¡æ ¸å·¥å…·å¤±è´¥:', error)
    throw error
  }
}

// æ‰¹å‡†å·¥å…·æäº¤
export async function approveToolSubmission(toolId: string) {
  return await reviewToolSubmission(toolId, 'approved')
}

// æ‹’ç»å·¥å…·æäº¤  
export async function rejectToolSubmission(toolId: string) {
  return await reviewToolSubmission(toolId, 'rejected')
}

// ç›´æ¥å®¡æ‰¹å·¥å…·æäº¤ï¼ˆä½¿ç”¨æ•°æ®åº“å‡½æ•°ï¼‰
export async function approveToolSubmissionDirect(
  submissionId: string,
  adminNotes?: string
) {
  try {
    throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
  } catch (error) {
    console.error('ç›´æ¥å®¡æ‰¹å¤±è´¥:', error)
    throw error
  }
}

// ç›´æ¥æ‹’ç»å·¥å…·æäº¤ï¼ˆä½¿ç”¨æ•°æ®åº“å‡½æ•°ï¼‰
export async function rejectToolSubmissionDirect(
  submissionId: string,
  adminNotes?: string
) {
  try {
    throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
  } catch (error) {
    console.error('ç›´æ¥æ‹’ç»å¤±è´¥:', error)
    throw error
  }
}

// è·å–ç”¨æˆ·åˆ—è¡¨
export async function getUsers(page = 1, limit = 20) {
  try {
    throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
  } catch (error) {
    console.error('âŒ è·å–ç”¨æˆ·åˆ—è¡¨å¼‚å¸¸:', error)
    return []
  }
}

// è·å–å·¥å…·åˆ—è¡¨ï¼ˆç®¡ç†å‘˜è§†å›¾ï¼‰
export async function getToolsAdmin(page = 1, limit = 20) {
  try {
    const token = await ensureAccessToken()
    throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜") => null)
    const list = json?.tools || []
    const start = (page - 1) * limit
    return list.slice(start, start + limit)
  } catch (error) {
    console.error('âŒ è·å–å·¥å…·åˆ—è¡¨å¼‚å¸¸:', error)
    return []
  }
}

// æ›´æ–°å·¥å…·ä¿¡æ¯
export async function updateTool(toolId: string, updates: Partial<Tool>) {
  const token = await ensureAccessToken()
  throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
}

// åˆ é™¤å·¥å…·
export async function deleteTool(toolId: string) {
  const token = await ensureAccessToken()
  throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
}

// è·å–ç®¡ç†å‘˜æ—¥å¿—
export async function getAdminLogs(page = 1, limit = 50) {
  try {
    const token = await ensureAccessToken()
    throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜") => null)
    const list = json?.logs || []
    const start = (page - 1) * limit
    return list.slice(start, start + limit)
  } catch (error) {
    console.error('âŒ ç®¡ç†å‘˜æ—¥å¿—å¼‚å¸¸:', error)
    return []
  }
}

// è·å–åˆ†ç±»åˆ—è¡¨
export async function getCategories() {
  try {
    const token = await ensureAccessToken()
    const json = throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
    // admin-categories è¿”å› { success, data }
    return json?.data || []
  } catch (error) {
    console.error('âŒ è·å–åˆ†ç±»å¼‚å¸¸:', error)
    return []
  }
}

// åˆ›å»ºåˆ†ç±»
export async function createCategory(category: {
  name: string
  slug: string
  description?: string
  color?: string
  icon?: string
  parent_id?: string
  sort_order?: number
  is_active?: boolean
}) {
  const token = await ensureAccessToken()
  return throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
}

// æ›´æ–°åˆ†ç±»
export async function updateCategory(id: string, updates: Partial<Record<string, unknown>>) {
  const token = await ensureAccessToken()
  return throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
}

// åˆ é™¤åˆ†ç±»
export async function deleteCategory(id: string) {
  const token = await ensureAccessToken()
  return throw new Error("ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
}

// æ–°å¢å·¥å…· - ç®€åŒ–ç‰ˆæœ¬
export async function createTool(tool: {
  name: string
  tagline?: string
  description?: string
  website_url: string
  logo_url?: string
  categories?: string[]
  features?: string[]
  pricing?: 'Free' | 'Freemium' | 'Paid' | 'Trial'
  featured?: boolean
}) {
  try {
    const { data, error } = await supabase
      .from('tools')
      .insert([{
        ...tool,
        status: 'pending',
        views: 0,
        upvotes: 0,
        rating: 0,
        review_count: 0,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        date_added: new Date().toISOString()
      }])
      .select()
      .single()

    if (error) throw error
    return data
  } catch (error) {
    console.error('âŒ åˆ›å»ºå·¥å…·å¤±è´¥:', error)
    throw error
  }
}